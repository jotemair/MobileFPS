using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Assertions;

public class Joystick : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler
{
    #region SerializeFields

    // Influences how far the joystick handle can visually move. Does not affect generated input.
    [SerializeField]
    private float _handleRange = 0.5f;

    // Influences the minimum ammount the joystick needs to be moved before it responds. Input will be zero in the deadzone
    [SerializeField]
    private float _deadZone = 0f;

    // Configuration to lock the joystick into vertical or horizontal only mode, or to use both axis
    [SerializeField]
    private AxisOptions _axisOption = AxisOptions.Both;

    // Reference to the background or base of the joystick
    [SerializeField]
    protected RectTransform _background = null;

    // Reference to the handle of the joystick
    [SerializeField]
    protected RectTransform _handle = null;

    // The input vector generated by the joystick
    [SerializeField]
    private Vector2 _input = Vector2.zero;

    #endregion

    #region Variables

    private RectTransform _baseRect = null;
    private Canvas _canvas = null;
    private Camera _cam = null;

    #endregion

    #region Properties

    // The horizontal component of the input
    public float Horizontal
    {
        get { return _input.x; }
    }

    // The vertical component of the input
    public float Vertical
    {
        get { return _input.y; }
    }

    // The full input vector
    public Vector2 Input
    {
        get { return _input; }
    }

    // Handle range, makes sure that the value is positive when it's set
    public float HandleRange
    {
        get { return _handleRange; }
        set { _handleRange = Mathf.Abs(value); }
    }

    // DeadZone, makes sure that the value is positive when it's set
    public float DeadZone
    {
        get { return _deadZone; }
        set { _deadZone = Mathf.Abs(value); }
    }

    // Axis option to lock joystick in a certain axis
    public AxisOptions AxisOption
    {
        get { return _axisOption; }
        set { _axisOption = value; }
    }

    #endregion

    #region Functions

    protected virtual void Start()
    {
        HandleRange = _handleRange;
        DeadZone = _deadZone;
        _baseRect = GetComponent<RectTransform>();
        _canvas = GetComponentInParent<Canvas>();

        Assert.IsNotNull(_canvas, "This script goes on a child in the Canvas");

        Vector2 center = new Vector2(.5f, .5f);
        _background.pivot = center;
        _handle.anchorMin = center;
        _handle.anchorMax = center;
        _handle.pivot = center;
        _handle.anchoredPosition = Vector2.zero;
    }

    // Apply axis options to the vector parameter
    private Vector2 LimitVectorAxis(Vector2 vec, AxisOptions axisOption)
    {
        return new Vector2( ((axisOption == AxisOptions.Vertical) ? 0f : vec.x), ((axisOption == AxisOptions.Horizontal) ? 0f : vec.y) );
    }

    // Clamp vector magnitude between a minimum value and 1f
    private Vector2 ClampVector(Vector2 vec, float min)
    {
        Vector2 clampedVec;

        float magnitude = vec.magnitude;
        if (magnitude > min)
        {
            if (magnitude > 1f)
            {
                clampedVec = vec.normalized;
            }
            else
            {
                clampedVec = vec;
            }
        }
        else
        {
            clampedVec = Vector2.zero;
        }

        return clampedVec;
    }

    // Convert raw input according to settings, move handle according to input
    public virtual void HandleInput(Vector2 rawInput)
    {
        _input = ClampVector(LimitVectorAxis(rawInput, _axisOption), _deadZone);
        
        Vector2 radius = _background.sizeDelta / 2f;
        _handle.anchoredPosition = _input * radius * _handleRange;
    }

    protected Vector2 GetRawInputFromEvent(PointerEventData eventData)
    {
        Vector2 rawInput = Vector2.zero;

        Vector2 position = RectTransformUtility.WorldToScreenPoint(_cam, _background.position);
        Vector2 radius = _background.sizeDelta / 2f;
        rawInput = (eventData.position - position) / (radius * _canvas.scaleFactor);

        return rawInput;
    }

    protected Vector2 ScreenPointToAnchoredPosition(Vector2 screenPosition)
    {
        Vector2 localPoint = Vector2.zero;

        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(_baseRect, screenPosition, _cam, out localPoint))
        {
            Vector2 pivotOffset = _baseRect.pivot * _baseRect.sizeDelta;
            return ((localPoint - (_background.anchorMax * _baseRect.sizeDelta)) + pivotOffset);
        }

        return Vector2.zero;
    }

    #endregion

    #region Interface

    public void OnDrag(PointerEventData eventData)
    {
        _cam = null;
        if (_canvas.renderMode == RenderMode.ScreenSpaceCamera)
        {
            _cam = _canvas.worldCamera;
        }

        Vector2 rawInput = GetRawInputFromEvent(eventData);

        HandleInput(rawInput);
    }

    public virtual void OnPointerDown(PointerEventData eventData)
    {
        OnDrag(eventData);
    }

    public virtual void OnPointerUp(PointerEventData eventData)
    {
        _input = Vector2.zero;
        _handle.anchoredPosition = Vector2.zero;
    }

    #endregion
}

public enum AxisOptions
{
    Both,
    Horizontal,
    Vertical
}
